<!DOCTYPE html>
<html lang="en">

<head>
  <title>Copper Sulfate Titration</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .container {
      display: flex;
      width: 90vw;
      height: 90vh;
      /* background-image: url("bg3.png"); */
      background-color: white;
      background-size: contain;
      background-repeat: no-repeat;
    }

    #canvasContainer {
      width: 60%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .controls {
      width: 40%;
      height: 100%;
      padding: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: space-around;
    }

    h1 {
      margin-bottom: 20px;
      text-align: center;
      color: #333;
    }

    button {
      background-color: #4CAF50;
      color: white;
      padding: 12px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #3e8e41;
    }

    button:disabled {
      background-color: #ccc;
      cursor: default;
    }

    .slider-box {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: #333;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 10px;
    }

    .result-container {
      margin-top: 20px;
      font-weight: bold;
      color: #333;
    }
  </style>

</head>

<body>
  <div class="container">
    <div id="canvasContainer">
    </div>

    <div class="controls">
      <h1>Copper Sulfate Titration</h1>
      <button id="Start">Start</button>
      <button id="Shake">Shake</button>
      <button id="Reset" disabled>Reset</button>

      <div class="slider-box">
        <label for="speed_change">Nozzle Open:</label>
        <input type="range" class="slider" id="speed_change" min="1" max="5" value="2" step="1">
      </div>
      <div class="slider-box">
        <label for="Normality_titrate">Normality of titrate:</label>
        <input type="range" class="slider" id="Normality_titrate" min=".1" max=".9" value=".6" step=".2">
      </div>
      <div class="slider-box">
        <label for="Volume_titrate">Volume of titrant (ml):</label>
        <input type="range" class="slider" id="Volume_titrate" min="1" max="15" value="10" step="1">
      </div>
      <div class="result-container">
        Volume added: <span id="valueDisplay">0 ml</span>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  
    

    <script>
    let normality_titrant;
    let volume_titrant;
    let vadded = 0;
    let normality_titrate = 1;
    let volume_titrate = 8;

    let equivalencePointVolume;
    let titrationFinished = false;

    let size;

    let shakingRotation = 0;
    let shakingRotationSpeed = 0.15;
    let flaskTouched = false;
    let bureteTouched = false;
    let liquidLevel;
    let buretteLiquidColor;
    let liquidDropInterval = 500;
    let buretesize = 10;
    let buretemainsize = 10;

    let flaskheight;
    let flaskwidth;
    let flaskX;
    let flaskY;
    let cropHeight;

    let croppedImg;
    let gifImage;
    let bureteImg, flaskImg, bottomImg, backgroundImage, flaskImgbk;

    let changetint;
    let initialColor, afterColor;
    let change;

    let buretetouchX;
    let buretetouchY;
    let flasktouchX;
    let flasktouchY;

    let ex2one = false;
    let exone = false;

    let darkness = 140;

    let canvasLocation;

    let onerun = true;
    let canvas;
    let turnslideractive = true;

    let container;
    let waterlevel;
    let showppt = 0;
    let variation;
    let variation2;
    let size_vary;
    let size_vary2;
    let number = 0;

    let waterheight;
    let ppt = true;
    let nxtx, nxty, nxtw, nxth;
    let shownext = false;

    // --- Titration Control Variables ---
    let titrationRunning = false; // Flag to track if titration is running
    let titrationStartTime = 0; // To store the time when titration starts
    let addLiquidDropInterval; // Global variable to store the interval ID

    function preload() {
      bureteImg = loadImage('burette51.png', loaded);
      flaskImgbk = loadImage('backflask.png', loaded);
      flaskImg = loadImage('frontflask.png', loaded);
      bottomImg = loadImage('water.png', loaded);
      backgroundImage = loadImage('bg.png', loaded);
    }

    let loadedImages = 0;

    function loaded() {
      loadedImages++;
      if (loadedImages === 5) {
        console.log('loaded success');
      }
    }

    function setup() {
      number = 0;

      container = select('#canvasContainer');

      if (windowWidth < 500) {
        size = (container.width - 10) / 22;
      } else {
        size = (container.height - 10) / 24;
      }
      nxtx = 17 * size;
      nxty = 21 * size;
      nxtw = 50;
      nxth = 50;
      console.log('size:', size);
      canvas = createCanvas(20 * size, 24 * size);
      canvas.parent("#canvasContainer");
      background(backgroundImage);

      slider1 = select('#speed_change');
      slider2 = select('#Normality_titrate');
      slider3 = select('#Volume_titrate');

      slider1.removeAttribute('disabled');
      slider2.removeAttribute('disabled');
      slider3.removeAttribute('disabled');

      normality_titrate = slider2.value() / 2;
      volume_titrate = slider3.value();

      buretteLiquidColor = color(255, 255, 255, 100);
      liquidLevel = (8 * size);
      flaskheight = 5 * size / 1.1;
      flaskwidth = 3.9 * size / 1.1;
      flaskX = width / 2 - .7 * size;
      flaskY = height / 2 + 5.3 * size;
      cropHeight = flaskheight - volume_titrate * 0.0675 * size;
      buretetouchX = 11 * size;
      buretetouchY = 13 * size;
      flasktouchX = 10.5 * size;
      flasktouchY = 19.5 * size;

      // --- Set initial color to dark brown ---
      initialColor = color(139, 69, 19, darkness);  // Dark brown
      afterColor = color(135, 206, 250, 200);  // Light blue 

      changetint = initialColor;

      let startButton = document.getElementById("Start");
      startButton.addEventListener("click", startTitration); 
      let resetButton = document.getElementById("Reset");
      resetButton.addEventListener("click", setup);
      let shakeButton = document.getElementById("Shake");
      shakeButton.addEventListener("click", shake);

      vadded = 0;

      canvasLocation = canvas.position();
      console.log("Canvas location:", canvasLocation);
    }

    function draw() {
      frameRate(30);
      canvas;
      change = slider1.value() / 5;
      background(backgroundImage);

      if (liquidLevel >= 1 && bureteTouched == true) {
        noStroke();
        fill(buretteLiquidColor);
        rect(width / 2 + .95 * size, 12.8 * size, change * size * .2 * random(.8, 1.1), random(8.7, 8.8) * size);
      }

      waterlevel = cropHeight;
      if (!slider3.elt.hasAttribute('disabled')) {
        volume_titrate = slider3.value();
        cropHeight = flaskheight - volume_titrate * 0.080765 * size;
      }
      if (ppt) {
        drawppt();
        if (showppt == true) {
          drawppt();
        } else {
          showppt++;
        }
      }

      flaskImg.resize(flaskwidth + 6, flaskheight);
      flaskImgbk.resize(flaskwidth, flaskheight);
      bottomImg.resize(flaskwidth, flaskheight);
      waterheight = (flaskheight - cropHeight) * .7;

      noStroke();
      fill(buretteLiquidColor);
      rect(width / 2 + .7 * size, 12.7 * size, size * 0.65, -liquidLevel * 1.35);
      push();
      image(bureteImg, width / 2 - 6.2 * size, .7 * size, 9.88 * size / 1, buretesize * 2.3 * size / 1);
      noStroke();
      pop();

      if (flaskTouched) {
        noStroke();
        fill(buretteLiquidColor);
        funflasktouched();
      } else {
        image(flaskImgbk, flaskX, flaskY, flaskwidth, flaskheight);
        image(flaskImg, flaskX, flaskY, flaskwidth, flaskheight);
        push();
        tint(changetint);
        if (waterheight < flaskheight) {
          let c = bottomImg.get(0, flaskheight - waterheight, flaskwidth, flaskheight);
          image(c, flaskX, flaskY + flaskheight - waterheight);
        } else {
          image(bottomImg, flaskX, flaskY + flaskheight - waterheight);
        }
        pop();
      }

      let valueDisplayElement = document.getElementById("valueDisplay");
      valueDisplayElement.innerText = floor(vadded * 100) / 100 + ' ml';

      if (onerun) {
        setup();
        onerun = !onerun;
      }
      // if (shownext == true) {
      //   // Display the button without blinking
      //   image(nextimg, nxtx, nxty, nxtw, nxth);
      // }
    }

    function mousePressed() {
      let dis_burete = dist(mouseX, mouseY, buretetouchX, buretetouchY);
      if (dis_burete <= 1.5 * size) {
        startTitration(); 
      }
      let dis_flask = dist(mouseX, mouseY, flasktouchX, flasktouchY);
      if (dis_flask <= 2.3 * size) {
        flaskTouched = !flaskTouched;
      }
      // if (mouseX > nxtx - nxtw / 4 && mouseX < nxtx + nxtw && mouseY > nxty - nxth / 4 && mouseY < nxty + nxth && vadded >= volume_titrant) {
      //   nextpressed();
      // }
    }

    function mouseReleased() {
      buretesize = buretemainsize;
    }

    function addLiquidDrop() {
      if (!titrationRunning) {
        return; 
      }

      let runonce = true;
      if (liquidLevel >= 1 && bureteTouched == true) {
    // Adjust this calculation based on your burette dimensions 
    liquidLevel -= (change * size / 5) * (20/ 50); // Example: Assuming burette height is 40 pixels
    cropHeight -= 2.0 * change;
    number += change;
    vadded =vadded+ 1* change;
  

        if (vadded >= volume_titrant / 2) {
          changetint = afterColor;
        }

        if (vadded >= volume_titrant && runonce) {
          console.log("Titration Complete!");
          shownext = true;
          runonce = false;
          stopTitration();
        }

        if (darkness <= 255 && runonce == false) {
          darkness += 10;
        }
      }
    }

    function stopTitration() {
        console.log("StopTitration() called"); // Debugging line
  // 1. Stop adding drops (clearInterval)
  clearInterval(addLiquidDropInterval); 
  // 2. Set titrationRunning to false
  titrationRunning = false; 
  // 3. Any other visual or logical changes for the end of the titration 
}

    function funflasktouched() {
      let shakingRotationOffset = sin(shakingRotation) * 6;
      push();
      translate(width / 2, 14 * size + 4 * size / 2);
      rotate(radians(shakingRotationOffset));
      image(flaskImgbk, flaskX - width / 2, flaskY - 16 * size, flaskwidth, flaskheight);
      push();
      tint(changetint);
      if (waterheight < flaskheight) {
        let c = bottomImg.get(0, flaskheight - waterheight, flaskwidth, flaskheight);
        image(c, flaskX - width / 2, flaskY + flaskheight - waterheight - (16 * size));
      } else {
        image(bottomImg, flaskX - width / 2, flaskY + flaskheight - waterheight);
      }
      pop();
      image(flaskImg, flaskX - width / 2, flaskY - 16 * size, flaskwidth, flaskheight);
      pop();
      shakingRotation += shakingRotationSpeed;
    }

    function startTitration() {
        console.log("startTitration() called"); // Debugging line
      normality_titrate = slider2.value() / 2;
      volume_titrate = slider3.value();
      if (turnslideractive == true) {
        cropHeight = flaskheight - volume_titrate * 0.8 * size;
        turnslideractive = false;
        setup();
      }

      buretesize = buretesize + 0.1;
      normality_titrant = random(0.80, .90);
      console.log("Normality =", normality_titrant);
      volume_titrant = (normality_titrant * volume_titrate) / normality_titrate;
      console.log("Volume Required", volume_titrant);
      bureteTouched = !bureteTouched;

      // Start the titration
      titrationRunning = true;
      titrationStartTime = millis(); // Record the start time

      // Start adding drops
      addLiquidDropInterval = setInterval(addLiquidDrop, liquidDropInterval); // Store interval ID

      slider2.attribute('disabled', true);
      slider3.attribute('disabled', true);
    }


    function shake() {
      flaskTouched = !flaskTouched;
    }

    function drawppt() {
      size_vary = Math.floor(random(0.2152, 0.2511) * size);
      size_vary2 = Math.floor(random(0.2152, 0.2511) * size);
      frameRate(30);
      fill(170, 74, 68, 255);
      noStroke();
      const upperBound = Math.floor(random(1, 2) + number * 1.25 - 5);

      for (let i = 0; i < upperBound * 6; i++) {
        variation = Math.floor(random(-1.4349, 1.4349) * size);
        variation2 = Math.floor(random(0.1793, 0.3587) * size);
        ellipse(flaskX + variation + 1.8 * size, flaskY + variation2 + 3.9 * size, size_vary / 4, size_vary2 / 4);
      }
    }

    // function nextpressed() {
    //   const queryParams = `&data3=${encodeURIComponent(volume_titrant)}&data4=${encodeURIComponent(normality_titrant)}`;
    //   fetch(`send.php?${queryParams}`, {
    //     method: 'GET',
    //     headers: {
    //       'Content-Type': 'application/json',
    //     },
    //   })
    //     .then(response => {
    //       if (response.ok) {
    //         return response.json();
    //       } else {
    //         throw new Error('Network response was not ok');
    //       }
    //     })
    //     .then(data => {
    //       console.log('Response from server (Page 1):', data);
    //       if (data.message === 'Value received successfully (Page 2)') {
    //         window.location.href = 'TitrationComp.php';
    //       } else {
    //         console.error('Unexpected server response:', data);
    //       }
    //     })
    //     .catch(error => {
    //       console.error('Error:', error);
    //     });
    // }
  </script>
  </>

  <script>
    $(document).ready(function () {
      var slider = $('#speed_change');
      var sliderValue = $('#speed');
      var slider2 = $('#Normality_titrate');
      var slider2Value = $('#Normality');
      var slider3 = $('#Volume_titrate');
      var slider3Value = $('#Volume');
      slider.on('input', function () {
        var value = slider.val();
        sliderValue.text(value);
      });
      slider2.on('input', function () {
        var value = slider2.val();
        slider2Value.text(value + ' N');
      });
      slider3.on('input', function () {
        var value = slider3.val();
        slider3Value.text(value + ' ml');
      });
    });

    const clickMeButton = document.getElementById("Reset");
    const submitButton = document.getElementById("Start");

    clickMeButton.addEventListener("click", () => {
      if (!submitButton.classList.contains("pushed")) {
        console.log("Click Me button clicked!");
      }
    });

    submitButton.addEventListener("click", () => {
      submitButton.classList.toggle("pushed");
      clickMeButton.disabled = submitButton.classList.contains("pushed");
    });

    clickMeButton.addEventListener("click", () => {
      clickMeButton.classList.add("clicked");
      setTimeout(() => {
        clickMeButton.classList.remove("clicked");
      }, 200);
    });
  </script>
</body>

</html>